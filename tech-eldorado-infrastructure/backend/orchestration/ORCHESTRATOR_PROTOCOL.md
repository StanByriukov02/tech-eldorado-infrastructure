# ПРОТОКОЛ ИСПОЛЬЗОВАНИЯ ОРКЕСТРАТА

**ЦЕЛЬ:** Минимизировать токены + ускорить работу  
**СТРАТЕГИЯ:** Умный роутинг + батчинг + кэширование + параллельное выполнение

═══════════════════════════════════════════════════════════════════════════════

## 🎯 КОГДА ИСПОЛЬЗОВАТЬ ОРКЕСТРАТ

### ✅ ИСПОЛЬЗУЙ ОРКЕСТРАТ (параллельный анализ):

1. **Глубокий анализ экосистемы:**
   - Изучение множества файлов одновременно
   - Синтез информации из разных источников
   - Выявление пробелов и противоречий

2. **Сложные архитектурные решения:**
   - Дизайн системы с множеством компонентов
   - Валидация через несколько экспертов
   - Поиск оптимального решения

3. **Критичные проверки:**
   - Соответствие протоколам (валидация)
   - Метакогнитивный анализ (сомнения)
   - Риск-анализ (asymmetric risk)

4. **Параллельная генерация кода:**
   - Несколько компонентов одновременно
   - Frontend + Backend параллельно
   - Database + API routes параллельно

### ❌ НЕ ИСПОЛЬЗУЙ ОРКЕСТРАТ (делай сам):

1. **Простые задачи:**
   - Создание одного файла
   - Простые правки
   - Копирование кода

2. **Рутинные операции:**
   - Обновление TODO
   - Чтение файлов
   - Поиск в коде

3. **Быстрые проверки:**
   - Синтаксис
   - Импорты
   - Базовые тесты

═══════════════════════════════════════════════════════════════════════════════

## 🧠 СОСТАВ ОРКЕСТРАТА

### 6 АГЕНТОВ (из rules.mdc):

1. **Architect (Claude 3.7 Sonnet):**
   - Роль: Архитектурные решения, системный дизайн
   - Когда: Сложные архитектурные задачи
   - Cost: $3/M input, $15/M output

2. **Reasoner (Kimi 2k):**
   - Роль: Глубокий анализ, длинный контекст (200k tokens)
   - Когда: Анализ больших документов, синтез
   - Cost: $0.55/M (дешево!)

3. **Constraint (o1-mini):**
   - Роль: Оптимизация, constraint satisfaction
   - Когда: Поиск оптимального решения
   - Cost: $3/M input, $12/M output

4. **Coder (DeepSeek-V3):**
   - Роль: Генерация кода, паттерны
   - Когда: Создание компонентов, рефакторинг
   - Cost: $0.00014/M input, $0.00028/M output (ОЧЕНЬ ДЕШЕВО!)

5. **Validator (Haiku 3.5):**
   - Роль: Быстрая валидация, проверки
   - Когда: Проверка соответствия, протоколы
   - Cost: $0.00025/M input, $0.00125/M output (ДЕШЕВО!)

6. **Fast (Gemini 2.5 Pro):**
   - Роль: Быстрые задачи, UI, простой анализ
   - Когда: Быстрые операции, простые задачи
   - Cost: $0.000125/M input, $0.0005/M output (САМОЕ ДЕШЕВО!)

═══════════════════════════════════════════════════════════════════════════════

## 💰 СТРАТЕГИЯ МИНИМИЗАЦИИ ТОКЕНОВ

### 1. УМНЫЙ РОУТИНГ (выбор дешёвой модели когда возможно):

```
ПРИОРИТЕТ (от дешёвого к дорогому):
1. Fast (Gemini) → $0.000125/M (самое дешёвое!)
2. Validator (Haiku) → $0.00025/M
3. Coder (DeepSeek) → $0.00014/M
4. Reasoner (Kimi) → $0.55/M (дешёво для длинного контекста!)
5. Architect (Claude) → $3/M (дорого, только когда нужно!)
6. Constraint (o1-mini) → $3/M (дорого, только для оптимизации!)
```

**ПРАВИЛО:**
- Если задача простая → Fast (Gemini)
- Если нужна валидация → Validator (Haiku)
- Если нужен код → Coder (DeepSeek)
- Если нужен анализ → Reasoner (Kimi)
- Если нужна архитектура → Architect (Claude)
- Если нужна оптимизация → Constraint (o1-mini)

### 2. БАТЧИНГ (объединение задач):

```
ВМЕСТО:
- Задача 1 → вызов модели → результат
- Задача 2 → вызов модели → результат
- Задача 3 → вызов модели → результат

ДЕЛАЙ:
- [Задача 1, Задача 2, Задача 3] → один вызов → все результаты
```

**ЭКОНОМИЯ:** 3× меньше вызовов API = меньше overhead!

### 3. КЭШИРОВАНИЕ (сохранение результатов):

```
ЕСЛИ:
- Анализ экосистемы уже был → использовать кэш
- Проверка протоколов уже была → использовать кэш
- Архитектурное решение уже было → использовать кэш

ТО:
- НЕ вызывать модель снова
- Использовать сохранённый результат
```

**ЭКОНОМИЯ:** 0 токенов на повторные запросы!

### 4. ПАРАЛЛЕЛЬНОЕ ВЫПОЛНЕНИЕ (одновременно, не последовательно):

```
ВМЕСТО:
- Архитектор работает → ждём → Reasoner работает → ждём → Coder работает

ДЕЛАЙ:
- Архитектор + Reasoner + Coder работают ОДНОВРЕМЕННО
- Результаты синтезируются после
```

**ЭКОНОМИЯ:** Время сокращается в 3×, токены те же!

═══════════════════════════════════════════════════════════════════════════════

## 🚀 ПРОТОКОЛ ИСПОЛЬЗОВАНИЯ

### ПРОТОКОЛ 1: ПРОСТАЯ ЗАДАЧА (делай сам)

```
ЗАДАЧА: Создать один файл, простая правка

ДЕЙСТВИЕ:
1. Делаю сам (без оркестрата)
2. Использую только свои токены
3. Быстро и дёшево

ПРИМЕР:
- Создать .env.example
- Обновить README
- Добавить один route
```

### ПРОТОКОЛ 2: СРЕДНЯЯ ЗАДАЧА (один агент)

```
ЗАДАЧА: Нужна экспертная помощь, но не критично

ДЕЙСТВИЕ:
1. Выбираю ОДИН подходящий агент (самый дешёвый!)
2. Задаю вопрос
3. Использую результат

ПРИМЕР:
- Валидация кода → Validator (Haiku) - $0.00025/M
- Генерация компонента → Coder (DeepSeek) - $0.00014/M
- Быстрый анализ → Fast (Gemini) - $0.000125/M
```

### ПРОТОКОЛ 3: СЛОЖНАЯ ЗАДАЧА (оркестрат параллельно)

```
ЗАДАЧА: Нужен глубокий анализ, несколько экспертов

ДЕЙСТВИЕ:
1. Распределяю задачи между агентами ПАРАЛЛЕЛЬНО
2. Каждый агент работает над своей частью
3. Синтезирую результаты

ПРИМЕР:
- Анализ экосистемы:
  * Architect → инфраструктура
  * Reasoner → протоколы
  * Constraint → департаменты
  * Coder → код
  * Validator → соответствие
  * Fast → приоритеты
- Все работают ОДНОВРЕМЕННО
- Синтез после
```

### ПРОТОКОЛ 4: КРИТИЧНАЯ ЗАДАЧА (оркестрат + валидация)

```
ЗАДАЧА: Архитектурное решение, критично для системы

ДЕЙСТВИЕ:
1. Оркестрат анализирует ПАРАЛЛЕЛЬНО
2. Architect синтезирует решение
3. Validator проверяет соответствие протоколам
4. Constraint оптимизирует
5. Финальная валидация

ПРИМЕР:
- Дизайн NCCL coordination
- Архитектура Database Schema
- Система коммуникации агентов
```

═══════════════════════════════════════════════════════════════════════════════

## 📊 ПРИМЕРЫ ОПТИМИЗАЦИИ

### ПРИМЕР 1: Анализ экосистемы

**БЕЗ ОПТИМИЗАЦИИ:**
```
1. Читаю файл 1 → 1000 токенов
2. Читаю файл 2 → 1000 токенов
3. Читаю файл 3 → 1000 токенов
4. Анализирую → 2000 токенов
ИТОГО: 5000 токенов, 4 последовательных шага
```

**С ОПТИМИЗАЦИЕЙ:**
```
1. Оркестрат читает 3 файла ПАРАЛЛЕЛЬНО → 3000 токенов
2. Reasoner синтезирует (дешёвый!) → 500 токенов
ИТОГО: 3500 токенов, 2 параллельных шага
ЭКОНОМИЯ: 30% токенов, 2× быстрее!
```

### ПРИМЕР 2: Генерация кода

**БЕЗ ОПТИМИЗАЦИИ:**
```
1. Architect проектирует → 2000 токенов (Claude дорогой!)
2. Coder генерирует код → 1000 токенов
ИТОГО: 3000 токенов, последовательно
```

**С ОПТИМИЗАЦИЕЙ:**
```
1. Coder генерирует код сразу (DeepSeek дешёвый!) → 100 токенов
2. Validator проверяет → 50 токенов
ИТОГО: 150 токенов, параллельно
ЭКОНОМИЯ: 95% токенов, быстрее!
```

### ПРИМЕР 3: Валидация протоколов

**БЕЗ ОПТИМИЗАЦИИ:**
```
1. Architect проверяет → 2000 токенов (Claude дорогой!)
ИТОГО: 2000 токенов
```

**С ОПТИМИЗАЦИЕЙ:**
```
1. Validator проверяет (Haiku дешёвый!) → 100 токенов
ИТОГО: 100 токенов
ЭКОНОМИЯ: 95% токенов!
```

═══════════════════════════════════════════════════════════════════════════════

## ✅ ЧЕКЛИСТ ПЕРЕД ИСПОЛЬЗОВАНИЕМ ОРКЕСТРАТА

**Перед вызовом оркестрата спросить:**

1. **Могу ли я сделать это сам?**
   - ДА → делаю сам (0 токенов оркестрата!)
   - НЕТ → следующий вопрос

2. **Нужен ли мне только один эксперт?**
   - ДА → вызываю одного агента (дешёвого!)
   - НЕТ → следующий вопрос

3. **Нужен ли параллельный анализ?**
   - ДА → оркестрат параллельно
   - НЕТ → один агент последовательно

4. **Критично ли это для системы?**
   - ДА → полный оркестрат + валидация
   - НЕТ → минимальный оркестрат

═══════════════════════════════════════════════════════════════════════════════

## 🎯 ПРАВИЛА ЭКОНОМИИ

### ПРАВИЛО 1: Дешёвые модели первыми

```
Fast (Gemini) → Validator (Haiku) → Coder (DeepSeek) → Reasoner (Kimi) → Architect (Claude)
```

### ПРАВИЛО 2: Батчинг всегда

```
Объединяй задачи в один запрос когда возможно
```

### ПРАВИЛО 3: Кэширование результатов

```
Сохраняй результаты анализа, не повторяй запросы
```

### ПРАВИЛО 4: Параллельное выполнение

```
Несколько агентов работают одновременно, не последовательно
```

### ПРАВИЛО 5: Минимальный оркестрат

```
Используй только необходимых агентов, не всех
```

═══════════════════════════════════════════════════════════════════════════════

**РЕЗУЛЬТАТ:**
- 50-95% экономия токенов
- 2-3× ускорение работы
- Умное использование ресурсов
- Быстрые простые задачи без оркестрата

**ОРКЕСТРАТ = ИНСТРУМЕНТ, НЕ КОСТЫЛЬ!** 🔥⚡

